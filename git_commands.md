# Git Commands

## Git  

* Проверка установленной версии git (либо ее наличия)
  * git **version** 
* Настройка конффигурации. в корневом каталоге юзера появляется файл .gitconfig с инфой (эта инфа в последствии отображается в отчете о коммите в строке **author**)
  * git **config** --global user.name **'Pasha'**
  * git **config** --global user.email **'kormeg@yandex.ru'**
  * git **config** -l

## Local Repository  

### Create
* инициализация репозитория. В текущей папке создается папка "repository_name", в которой инициализируется репозиторий ( создается скрытая папка .git со всякой шляпой). Чтобы инициализировать репозиторий в текущей(уже созданной) папке: git **init .** точка указывает на текущую папку, ее указывать не обязательно
  * git **init** repository_name
* можно создать файл **.gitignore** в этой же папке (этот файл указывает гиту, что из текущего и будущего содержимого папки игнорировать. Этот файл лучше запушить до того, как на репозиторий зальется то, что не должно и далее редактировать заранее, прежде, чем пушишь папку с "лишними"  файлами
[про gitignore](https://support.rdb24.com/hc/ru/articles/115000463769-%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-gitignore)
* состояние локального репозитория на текущий момент (показаны несохраненные изменения если они есть. созданный или отредактированный файл отображается **красным** > добавленный (git **add**) - **зеленым** > после создания коммита (git **commit**) - **исчезает**
  * git **status** 

### Add
* добавление всех текущих файлов с несохраненными изменениями или недавно созданных файлов (для будущего коммита). Если нужно добавить не все изменения, а только конкретные: git **add** file_name.txt(.py,.md,.ipynb...)
  * git **add .**
* отображение результата, который будет, если сейчас сделать коммит. (на **зеленой** стадии, после **add**)
  * git **diff --staged**
* возврат файла из **зеленого** в **красное** состояние. то есть после команды git **add** появилась необходимость убрать файл из будущего коммита
  * git **rm --cached** file_name.txt(.py,.md,.ipynb) 
  * git **restore --staged .** другой вариант того же самого (.) значит **всё**

### Commit
* Фиксация измененений во всех файлах для которых была применена команда git **add** (после **-m** в ковычкак идет комментарий, который будет отображаться в истории изменений это как бы название изменения. Что-то короткое понятное и конкретное) 
  * git **commit -m** "comment"
* Возвращение файла к состоянию последнего коммита. то есть, если по ошибке сделаны изменения в файле, файл находится в **красном** состоянии и его нужно вернуть в состояние до внесения изменений
  * git **restore** file_name.txt(.py,.md,.ipynb)
  * git **checkout** -- file_name.txt(.py,.md,.ipynb) - **другой вариант** этого действия в bash точно работает в powershell - не проверено
* просмотр истории коммитов. чтобы посмотреть определенное количество последних: git **log -2** (**2** - кол-во), с подробностямиизменений: git **log -2 -p**
  * git **log**
  * git **log --pretty=oneline** - то же, но компактно, без дат и авторов коммитов
* Изменение последнего коммита(открывается редактор и в нем вводится новый текст. чтобы его отредактировать нажимается**Insert**. **esc :w q!** - сохранение и выход из редактора) вроде бы можно менять и сам коммит, но это (в совместных проектах этого делать не стоит, ибо может привести к конфликтам)  **!!!ОЧЕНЬ МУТОРНАЯ КОМАНДА. НЕ ИСПОЛЬЗОВАТЬ!!!**
  * git **commit --amend**


 
## Remote Repository  
* Создание удаленного репозитория
  1. регистрация на гитхаб
  2. в профиле вкладка **Repositories** > кнопка **New** > вводим название **Repository name** > кнопка **Create repository
  3. копируем содержимое адресной строки
* создание в папке с локальным репозиторием ссылки на удаленный репозиторий **origin** общепринятое название ссылки. (может быть любым)
  * git **remote** add origin `https://github.com/blabla_everything_from_address_bar`**.git**
* Проверка наличия в локальном репозитории ссылки на удаленный. возвращает имя при наличии
  * **git remote** 
* Переименование главной ветки(при необходимости). Когда создан локальный репозиторий, инициирующий(любой первый) коммит создает главную ветку с названием **master**. **-M** указывает на главную ветку, **main** - новое название ветки
  * git **branch -M** main
* отправка коммита на удаленный репозиторий. Первая отправка: git **push -u** origin main (**-u**(set upstream) - означает, что все последующие коммиты будут по умолчанию отправляться на указанную ветку **main** указанного репозитория **origin**.) возможно, это необязательное действие. в дальнейшем:
  * git **push**
* Создание клона удаленного репозитория создается новая папка
  * git **clone** `https://blabla_everything_from_address_bar`**.git** 
* Затягивание измененного проекта из удаленного в локальный репозиторий (в совместных проектах при наличии изменений главной ветки, которых нет в локальном репозитории git не позволяет сделать коммит, пока не затянешь чужие коммиты к себе. указывать **origin main** необязательно
  * git **pull** origin main

### Commit destroy
* Уничтожение определенного кол-ва **последних** коммитов **локально**. (**3** - кол-во уничтожаемых коммитов, без цифры уничтожается 1) При этом проект возвращается к предыдущим версиям.
  * git **reset --hard HEAD~**`3`
* Превращение определенного кол-ва последних коммитов (**кроме первого**) в один. (**3** - кол-во объединяемых коммитов) При этом все измененные и добавленные **суммарно в выбранных комитах** файлы переходят в зеленое состояние, но не исчезают с удаленного репозитория
  * git **reset --soft HEAD~**`3`
* закрепление изменений (**удаления коммитов**) в удаленном репозитории и для **hard** и для **soft**
  * git **push -f** origin main
* после этого для **soft** делаем коммит всех файлов и проект возвращается к исходному состоянию но с одним коммитом вместо нескольких
  * git **commit -m** 'all in one commit'

## Branches
* просмотр списка веток и активной ветки
  * git **branch**
* создание новой ветки локально. на новой ветке доступно все что ина главной. можно вносить изменения не зтрагивая основную ветку
  * git **branch** branch_name
* переход на существующую локальную ветку
  * git **checkout** branch_name
* создание и переход одновременно
  * git **checkout -b** branch_name 
* отправка новой ветки на удаленный репозиторий можно отправлять вместе с готовыми изменениями
  * git **push --set-upstream** origin branch_name

### Pull request. Merge
* **pull request** - функциональость **github**. Команды для этого не существует, поэтому это делается непосредственно на гитхабе
* затягивание чужих веток из удаленного репозитория к себе (если ты получил pull request или просто хочешь себе чужую ветку или свою удаленную локально)  fetch не создает ветку локально он лишь создает список удаленных веток на который можно посмотреть и при надобности запулить. *если сделать **git pull** вместо **git fetch**, то все принудительно смерджится. если проверка не требуется, можно просто пулить
  * git **fetch**
* просмотр списка веток после git fetch (**-v** - verbose. к каждой местной или удаленной ветке добавляется название последнего коммита, **-a** - all. добавляет к списку локальных веток удаленные, но только после **git fetch**) 
  * git **branch -v -a**  
* переход на удаленную ветку вместе с созданием локальной
  * git **switch** branch_name
  * git **checkout** branch_name - то же самое другим способом
* слияние ответвления с главной веткой. Если ты находишься на удаленной или локальной ветке, которую собераешься мерджить, то необходимо перейти на главную ветку **git checkout** main. по окончании слияния его необходимо запушить.
  * git **merge** branch_name
* удаление ветви после слияния или просто удаление ненужной ветки **локально** вместо **-D** можно использовать **-d**, тогда при наличии несохраненных изменений на этой ветке git предупредит и переспросит. **-D** удаляет все без лишних разговоров
  * git **branch -D** branch_name  
* удаление ветви **удаленно** (может быть отдельным действием как и прошлая команда. После мерджа остается лишняя ветвь локально и удаленно, поэтому эти действия выполняются последовательно, но не стоит воспринимать их как одно. В остальных случаях можно на свое усмотрение удалять любые, как локальные, так и удаленные ветви
  * git **push -d** origin branch_name 
  * git **push origin --delete** branch_name - то же самое другим способом

## Tags and moving around the project

* Просмотр проекта на этапе одного из прошлых коммитов. `135e0b55c1414459bc7c59728084b0b78a5a138a` - хэш коммита. он указан для каждого коммита в списке получаемом по команде **git log**. В этом состоянии можно просматривать и менять файлы не внося никких изенений ни на каких ветках ни локально ни удаленно.
  * git **checkout** `135e0b55c1414459bc7c59728084b0b78a5a138a`
* Переход обратно к текущему состоянию главной ветки проекта **main(master)** - имя твоей главной ветки
  * git **checkout main**
  * git **switch -** - другой вариант того же действия
* Сохранение изменений сделанных в режиме просмотра старого коммита на отдельной ветке с переходом на нее
  * git **switch -c** new_branch_name
* Просмотр списка тэгов
  * git **tag**
* Создание тэга на стадии текущего коммита (тегами отмечаются важные коммиты. в коммитах есть хэши и комментарии, по которым их можно найти, но основные точки сохранения проекта (версии) тэгируются.
  * git **tag** v1.0.0
* Создание тэга на выбранном предыдущем коммите. `135e0b55c1414459bc7c59728084b0b78a5a138a` - хэш коммита.
  * git **tag -a** v1.1.0 `135e0b55c1414459bc7c59728084b0b78a5a138a`
* Отправка определенного тэга в удаленный репозиторий (**add** и **commit** не требуется) **v1.0.0** - версия. так принято тэгировать, но можно как угодно
  * git **push** origin v1.0.0
* Отправка всех тэгов
  * git **push** origin --tags 
* Переход на версию проека по тэгу (действие иденитичное первому в этом разделе с последующей цепочкой возможных действий)
  * git **checkout** v1.0.0
* Удаление тэга **локально**. **-D** для тэгов не работает
  * git **tag -d** v1.0.0
* Удаление тэга **удаленно**. Альтернативные способы удаления не пробовал
  * git **push -d** origin v2.0.4

























